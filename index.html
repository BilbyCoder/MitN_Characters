<!DOCTYPE html>

<html>
    <head>
        <title>
            Mutants in the Now - Character Sheet Manager
        </title>
        <style>
                tr:nth-child(even) {
                    background-color: rgba(157, 253, 205, 0.4);
                }
        </style>
    </head>

    <body>
        <div><label>Name: <input id="char_name"/></label></div>
        <div>
            <h1>Attributes</h1>
            <table attributes id="attribute-block">
                <tr>
                    <th colspan="2">Attribute Value</th>
                    <th colspan="2">Prime Modifier</th>
                    <th>Skill Base</th>
                    <th>Skill Gain</th>
                    <th>Damage Dice</th>
                    <th>GOO-P</th>
                    <th>Roll</th>
                    <th>Base Result</th>
                    <th>Dice</th>
                    <th>Bonus</th>
                </tr>
            </table>
        </div>

        <div>
            <h1>Background Rolls</h1>
            <label><button id="add_background">Add Background Roll</button></label>
            <table id="background_block">
                <th>Table ID</th>
                <th>Result</th>
                <th>Description</th>
                <th>Bonuses</th>
                <th>Roll Result</th>
                <th>Modifier</th>
                <th>Roll</th>
            </table>
        </div>

        <div>
            <h1>Save and Restore</h1>
            <label>Character Code:<br><textarea id="char_code"></textarea></label>
            <br>
            <button name="update" id="update_button">Update Code</button><button id="load_character">Load Code</button>
        </div>

        <script type="module">
            import { attribute_names, attribute_table } from "./modules/data/attribute_data.js";
            import { get_attribute, roll_attribute} from "./modules/attribute.js";
            import { new_background} from "./modules/backgrounds.js";
            import { roll_percent, restore_dice_set} from "./modules/util/utils.js"
            
            // Attributes
            const dice_faces = ["‚öÄ","‚öÅ","‚öÇ","‚öÉ","‚öÑ","‚öÖ"]
            let char_name = ""
            let attribute_rolls = []
            
            function update_attribute_row(attribute_line, row) {
                let attribute_id = row.rowIndex - 1;
                add_cell(attribute_line.name, row, 0);
                add_cell(attribute_line.value, row, 1);
                add_cell(`+${attribute_line.short}`, row, 2);
                add_cell(attribute_line.mod, row, 3);
                add_cell(`${attribute_line.skill_base}%`, row, 4);
                add_cell(`${attribute_line.skill_gain}%`, row, 5);
                add_cell(attribute_line.damage_dice[2], row, 6);
                add_cell(attribute_line.goop, row, 7);


                if (attribute_line.roll !== undefined) {
                    add_cell(attribute_line.base_roll.total, row, 9)
                    let d1 = dice_faces[attribute_line.base_roll.results[0] - 1]
                    let d2 = dice_faces[attribute_line.base_roll.results[1] - 1]
                    let d3 = dice_faces[attribute_line.base_roll.results[2] - 1]
                    let d4 = dice_faces[attribute_line.base_roll.results[3] - 1]

                    if (d1 === undefined || d2 === undefined || d3 === undefined || d4 === undefined) {
                        add_cell(`----`, row, 10)
                    } else  {
                        add_cell(`${d1}${d2}${d3}${d4}`, row, 10);
                    }

                    let attribute_bonus
                    if (row.cells[11] === undefined) {
                        attribute_bonus = row.insertCell(11);
                    } else {
                        attribute_bonus = row.cells[11]
                    }

                    let bonus_field = document.createElement("input")
                    bonus_field.type="number"
                    bonus_field.value = attribute_line.base_modification
                    bonus_field.setAttribute("style", "width: 4em")
                    bonus_field.onchange = function(evt) {
                        attribute_line.base_modification = Number(evt.target.value)
                        
                        let attribute_total = attribute_line.base_roll.total + attribute_line.base_modification;
                        row.cells[1].innerHTML = `${attribute_total}`;
                        let new_values = get_attribute(attribute_line.name, attribute_line.short, attribute_line.base_roll, attribute_line.base_modification)

                        update_attribute_row(new_values, row, attribute_id)
                    }

                    attribute_bonus.replaceChildren(bonus_field);
                    attribute_rolls[attribute_id] = attribute_line
                }
            }

            function update_background_row(data, row)
            {
                row.cells[0].children[0].value = data.table_id;
                row.cells[1].innerText = data.roll ? data.roll.total + data.modifier : "--";
                row.cells[2].children[0].value = data.description;
                row.cells[3].children[0].value = data.bonuses;
                row.cells[4].innerText = data.roll ? `${data.roll.results[0]}${data.roll.results[1]}` : "--";
                row.cells[5].children[0].value = data.modifier ? data.modifier : 0;
            }

            function add_cell(cell_string, row, index)
            {
                if (row.cells[index] === undefined) {     
                    var cell = row.insertCell(index)
                } else {
                    var cell = row.cells[index]
                }
                
                cell.innerHTML = `${cell_string}`
            }

            let character_data = []
            let attribute_block = document.getElementById("attribute-block")
        
            for (var attr in attribute_names) {
                let full_name = attribute_names[attr][0]
                let short_name = attribute_names[attr][1]
                let attribute_line = get_attribute(full_name, short_name, -1);
                attribute_rolls[attr] = attribute_line

                let new_row = attribute_block.insertRow(-1);
                new_row.id = `row_${attr}`
                
                update_attribute_row(attribute_line, new_row)
                
                let reroll_cell = new_row.insertCell(-1)
                let link = document.createElement('a')
                link.href = "#"
                link.innerText = "üé≤"
                link.onclick = function (evt) {
                    attribute_line = roll_attribute(full_name, short_name)
                    update_attribute_row(attribute_line, new_row, attr)
                }

                reroll_cell.append(link)
            }

            let backgrounds = []

            // Backgrounds
            let background_button = document.getElementById("add_background");
            let background_table = document.getElementById("background_block");

            function create_background_row(background_row)
            {
                let new_row = background_table.insertRow(-1)
                
                let id_cell = new_row.insertCell(-1)
                //id_cell.innerHTML = "<label> ID: <input maxLength =\"6\" /> </label>"
                let id_label = document.createElement("label")
                let id_input = document.createElement("input")
                
                id_input.setAttribute("maxLength", "6")
                id_input.onchange = function(evt) {
                    background_row.table_id = evt.target.value
                    update_background_row(background_row, new_row)
                }

                id_cell.appendChild(id_input)
                
                let result_cell = new_row.insertCell(-1)

                let description_cell = new_row.insertCell(-1)
                let description_input = document.createElement("textarea")
                description_input.onchange = function (evt) {
                    background_row.description = evt.target.value;
                    update_background_row(background_row, new_row);
                }
                description_cell.appendChild(description_input)

                let bonus_cell = new_row.insertCell(-1)
                let bonus_input = document.createElement("textarea")
                bonus_input.onchange = function(evt) {
                    background_row.bonuses = evt.target.value;
                    update_background_row(background_row, new_row)
                }

                bonus_cell.appendChild(bonus_input)

                let roll_result = new_row.insertCell(-1)

                let modifier_cell = new_row.insertCell(-1)
                let modifier_input = document.createElement("input");  
                modifier_input.type = "number"
                modifier_input.min = -100
                modifier_input.max = 100
                modifier_input.value = 0
                modifier_input.setAttribute("style", "width: 4em")
                modifier_input.onchange = function (evt) {
                    console.log(evt);
                    background_row.modifier = evt.target.valueAsNumber
                    update_background_row(background_row, new_row)
                }

                modifier_cell.appendChild(modifier_input)

                let reroll_cell = new_row.insertCell(-1)
                let roll_link = document.createElement('a')
                roll_link.href = "#"
                roll_link.innerText = "üé≤"
                roll_link.onclick = function (evt) {
                    background_row.roll = roll_percent()
                    update_background_row(background_row, new_row)
                }
                reroll_cell.append(roll_link)

                let save_cell = new_row.insertCell(-1)
                let save_link = document.createElement('a')
                save_link.href = "#"
                
                save_cell.append(save_link)

                backgrounds.push(background_row)
                update_background_row(background_row, new_row)
                console.log(backgrounds)
            }

            background_button.onclick = function (evt) {
                create_background_row(new_background())
            }

            // Encode the character
            let name = document.getElementById("char_name")
            let char_code = document.getElementById("char_code")
            let text_encoder = new TextEncoder()
            name.onchange = function (evt) {
                char_name = evt.target.value;
                generate_character_code()
            }

            let update_button = document.getElementById("update_button")
            
            update_button.onclick = function(evt) {
                generate_character_code()
            }

            function encode_string(enc_string) {
                if (!enc_string) enc_string = ""
                let u8_string = text_encoder.encode(enc_string)
                return [u8_string, u8_string.length]
            }

            function write_encode_to_data(encoded_string, offset, dataview)
            {
                let string_length = encoded_string[1];
                dataview.setUint16(offset, string_length)
                offset += 2

                for (let index = 0; index < string_length; index += 1) {
                    dataview.setUint8(offset + index, encoded_string[0][index])
                }

                return string_length + 2
            }

            function generate_character_code()
            {
                let buffer_size = 0
                // first the name is encoded
                let name_enc = encode_string(name.value)
                buffer_size += 2 + name_enc[1]
                
                // next we encode the attribute rolls and modifications.  Each attribute
                // is made up of the four dice rolls and any modification the user has
                // applied.
                let attributes = []
                for (attr in attribute_rolls) {
                    let current_attribute = attribute_rolls[attr]
                    
                    if (current_attribute.base_roll === undefined) {
                        attributes = attributes.concat([0,0,0,0])
                    }
                    else
                    {
                        attributes = attributes.concat(current_attribute.base_roll.results)
                    }

                    attributes.push(current_attribute.base_modification)
                }

                buffer_size += attributes.length

                console.log(background_table.rows.length)
                
                let background_data = []
                for (let background_id in backgrounds)
                {
                    let data = backgrounds[background_id];
                    let table_id = encode_string(data.table_id);
                    let description = encode_string(data.description);
                    let bonuses = encode_string(data.bonuses);
                    buffer_size += 9 + table_id[1] + description[1] + bonuses[1];

                    background_data.push({
                        table_id: table_id,
                        roll: data.roll,
                        description: description,
                        bonuses: bonuses,
                        modifier: data.modifier
                    })
                }

                buffer_size += 1 // To acomodate how many background tables there are

                let buffer = new ArrayBuffer(buffer_size)
                let view = new DataView(buffer)
                let offset = 0                
                offset += write_encode_to_data(name_enc, offset, view)

                for (let i = 0; i < attributes.length; i++) {
                    view.setInt8(offset, attributes[i])
                    offset += 1
                }

                view.setUint8(offset, background_data.length)
                offset += 1

                for (let background_id in background_data) {
                    let data = background_data[background_id];
                    offset += write_encode_to_data(data.table_id, offset, view);
                    offset += write_encode_to_data(data.description, offset, view);
                    offset += write_encode_to_data(data.bonuses, offset, view);

                    if (data.roll) {
                        view.setUint8(offset, data.roll.results[0]);
                        offset += 1;
                        view.setUint8(offset, data.roll.results[1]);
                        offset += 1;
                    } else {
                        view.setUint8(offset, 11);
                        offset += 1;
                        view.setUint8(offset, 11);
                        offset += 1;
                    }
                    
                    view.setInt8(offset, data.modifier);
                    offset += 1;
                }

                let buffer_array = new Uint8Array(buffer)

               char_code.value = buffer_array.toBase64({"alphabet":"base64url"})
            }

            let load_character_button = document.getElementById("load_character")
            let decoder = new TextDecoder()
            
            load_character_button.onclick = function (evt) {
                load_code()
            }

            function decode_string(buffer, view, offset) {
                let string_length = view.getUint16(offset)
                console.log(`starting offset: ${offset} string length: ${string_length}`)
                offset += 2;

                let decoded_string = decoder.decode(buffer.slice(offset, string_length + offset))
                console.log(decoded_string)
                offset += string_length
                console.log(offset)
                return [decoded_string, offset]
            }

            function load_code()
            {
                let buffer_array = Uint8Array.fromBase64(char_code.value, {"alphabet":"base64url"})
                let view = new DataView(buffer_array.buffer)
                let offset = 0
                
                // first we restore the name
                let [ret_string, new_offset] = decode_string(buffer_array, view, offset);
                name.value = ret_string;
                offset = new_offset;
                
                // now we restore the attributes
                for (let i = 0; i  < 8; i++) {
                    let attribute_offset = offset
                    let d1 = view.getInt8(attribute_offset)
                    let d2 = view.getInt8(attribute_offset + 1)
                    let d3 = view.getInt8(attribute_offset + 2)
                    let d4 = view.getInt8(attribute_offset + 3)
                    let mod = view.getInt8(attribute_offset + 4)
                    let roll_result = restore_dice_set([d1, d2, d3, d4], 6)

                    let full_name = attribute_names[i][0];
                    let short_name = attribute_names[i][1];

                    let attribute_line = get_attribute(full_name, short_name, roll_result, mod)
                    let current_row = attribute_block.rows[i + 1]
                    update_attribute_row(attribute_line, current_row, i)
                    offset += 5
                }

                let background_count = view.getUint8(offset);
                offset += 1;

                for (let index = 0; index < background_count; index ++) {
                    let background = {}
                    let [id_string, id_offset] = decode_string(buffer_array, view, offset);
                    offset = id_offset;
                    background.table_id = id_string;

                    let [bak_string, bak_offset] = decode_string(buffer_array, view, offset);
                    offset = bak_offset;
                    background.description = bak_string;

                    let [bns_string, bns_offset] = decode_string(buffer_array, view, offset);
                    offset = bns_offset;
                    background.bonuses = bns_string

                    let d1 = view.getUint8(offset)
                    let d2 = view.getUint8(offset + 1)
                    if (d1 < 11 && d2 < 11) {
                        background.roll = roll_percent([d1, d2])
                    }
                    else {
                        background.roll = null
                    }

                    background.modifier = view.getInt8(offset + 2)
                    create_background_row(background)
                    offset += 3
                }
            }
        </script>
    </body>
</html>